// 14mod3.s
// Константы для вывода
.data
newline: .ascii "\n"       // Символ новой строки
zero_str: .ascii "0"       // Строка для вывода нуля

.text
.global _main
.align 2


// atoi: преобразует строку в целое число
// Вход: X0 - адрес строки
// Выход: X0 - число

atoi:
    mov x1, #0              // Инициализация результата (число)
    mov x2, #0              // Для хранения текущего символа
atoi_loop:
    ldrb w2, [x0], #1       // Загружаем байт из строки и двигаем указатель
    cbz w2, atoi_end        // Если встретили нуль-терминатор (конец строки)
    sub x3, x2, #'0'        // Преобразуем ASCII в цифру (char to int)
    cmp x3, #9              // Проверяем, что это цифра 0-9
    b.hi atoi_end           // Если не цифра - завершаем
    mov x4, #10             
    mul x1, x1, x4          // Умножаем текущий результат на 10
    add x1, x1, x3          // Добавляем новую цифру
    b atoi_loop             // Повторяем цикл
atoi_end:
    mov x0, x1              // Возвращаем результат в X0
    ret


// is_prime: проверяет, является ли число простым
// Вход: X0 - число для проверки
// Выход: X0 - 1 (простое), 0 (составное)

is_prime:
    cmp x0, #1              
    b.le not_prime          // Числа ≤1 не простые
    cmp x0, #2              
    b.eq prime              // 2 - простое
    tst x0, #1              
    b.eq not_prime          // Чётные числа >2 не простые

    mov x1, #3              // Начальный делитель = 3
    mov x2, x0              // Сохраняем оригинальное число в X2
is_prime_loop:
    udiv x3, x2, x1         // X3 = число / текущий_делитель
    cmp x1, x3              
    b.gt prime              // Если делитель > sqrt(n), число простое
    msub x4, x1, x3, x2     // X4 = n % текущий_делитель (остаток)
    cbz x4, not_prime       // Если остаток 0 - число составное
    add x1, x1, #2          // Проверяем только нечётные делители (+2)
    b is_prime_loop         // Повторяем цикл
prime:
    mov x0, #1              // Возвращаем 1 (простое)
    ret
not_prime:
    mov x0, #0              // Возвращаем 0 (составное)
    ret


// print_number: выводит число в стандартный вывод
// Вход: X0 - число для вывода

print_number:
    stp x29, x30, [sp, #-32]! // Сохраняем регистры в стек
    mov x29, sp
    mov x1, x0              // Сохраняем число в X1
    cmp x1, #0              // Проверка на ноль
    b.ne not_zero
    // Спецобработка для нуля
    mov x0, #1              // file descriptor (stdout)
    adrp x2, zero_str@PAGE  // Адрес строки "0"
    add x2, x2, zero_str@PAGEOFF
    mov x3, #1              // Длина строки
    mov x16, #4             // Системный вызов write
    svc #0
    b print_end
not_zero:
    mov x3, #10             // Основание системы счисления
    mov x4, #0              // Счётчик цифр
    add x5, x29, #31        // Буфер в стеке (32 байта)
digit_loop:
    cmp x1, #0              // Пока число не ноль
    beq reverse_digits
    udiv x6, x1, x3         // Делим число на 10
    msub x7, x6, x3, x1    // Получаем остаток (последняя цифра)
    add x7, x7, #'0'        // Преобразуем цифру в ASCII
    strb w7, [x5]           // Сохраняем в буфер
    sub x5, x5, #1          // Двигаем указатель назад
    add x4, x4, #1          // Увеличиваем счётчик цифр
    mov x1, x6              // Обновляем число
    b digit_loop
reverse_digits:
    add x5, x5, #1          // Корректируем указатель на начало цифр
    mov x0, #1              // stdout
    mov x1, x5              // Адрес буфера
    mov x2, x4              // Количество цифр
    mov x16, #4             // Системный вызов write
    svc #0
print_end:
    ldp x29, x30, [sp], #32 // Восстанавливаем регистры
    ret


// Main
_main:
    mov x19, x0             // Сохраняем argc (количество аргументов)
    mov x20, x1             // Сохраняем argv (массив строк)

    cmp x19, #2             // Проверка наличия аргументов
    b.lt no_args            // Если аргументов нет

    mov x21, #1             // Индекс аргумента (argv[0] - имя программы)
    mov x22, #0             // Счётчик простых чисел
loop_args:
    cmp x21, x19            // Проверяем, обработаны ли все аргументы
    b.ge end_loop_args

    ldr x0, [x20, x21, lsl #3] // Загружаем argv[x21] (адрес строки)
    bl atoi                 // Преобразуем строку в число
    bl is_prime             // Проверяем на простоту
    cmp x0, #1              // Если простое (возвращено 1)
    b.ne next_arg
    add x22, x22, #1        // Увеличиваем счётчик
next_arg:
    add x21, x21, #1        // Переходим к следующему аргументу
    b loop_args

end_loop_args:
    mov x0, x22             // Загружаем количество простых чисел
    bl print_number         // Выводим результат
    // Вывод символа новой строки
    mov x0, #1              // stdout
    adrp x1, newline@PAGE
    add x1, x1, newline@PAGEOFF
    mov x2, #1              // Длина строки
    mov x16, #4             // Системный вызов write
    svc #0
    b exit

no_args:                    // Обработка случая без аргументов
    mov x0, #0              // Выводим 0
    bl print_number
    // Вывод новой строки
    mov x0, #1
    adrp x1, newline@PAGE
    add x1, x1, newline@PAGEOFF
    mov x2, #1
    mov x16, #4
    svc #0

exit:
    mov x0, #0              // Код возврата 0
    mov x16, #1             // Системный вызов exit
    svc #0